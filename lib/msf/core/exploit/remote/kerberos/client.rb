# -*- coding: binary -*-

module Msf
  class Exploit
    class Remote
      module Kerberos
        module Client
          include Msf::Exploit::Remote::Kerberos::Client::Base
          include Msf::Exploit::Remote::Kerberos::Client::AsRequest
          include Msf::Exploit::Remote::Kerberos::Client::AsResponse
          include Msf::Exploit::Remote::Kerberos::Client::TgsRequest
          include Msf::Exploit::Remote::Kerberos::Client::TgsResponse
          include Msf::Exploit::Remote::Kerberos::Client::Pac
          include Msf::Exploit::Remote::Kerberos::Client::CacheCredential

          # @!attribute client
          #   @return [Rex::Proto::Kerberos::Client] The kerberos client
          attr_accessor :client

          def initialize(info = {})
            super

            register_options(
              [
                Opt::RHOST,
                Opt::RPORT(88),
                OptInt.new('Timeout', [true, 'The TCP timeout to establish connection and read data', 10])
              ], self.class
            )
          end

          # Returns the target host
          #
          # @return [String]
          def rhost
            datastore['RHOST']
          end

          # Returns the remote port
          #
          # @return [Integer]
          def rport
            datastore['RPORT']
          end

          # Returns the TCP timeout
          #
          # @return [Integer]
          def timeout
            datastore['Timeout']
          end

          # Returns the kdc peer
          #
          # @return [String]
          def peer
            "#{rhost}:#{rport}"
          end

          # Creates a kerberos connection
          #
          # @param opts [Hash{Symbol => <String, Integer>}]
          # @option opts [String] :rhost
          # @option opts [<String, Integer>] :rport
          # @return [Rex::Proto::Kerberos::Client]
          def connect(opts={})
            kerb_client = Rex::Proto::Kerberos::Client.new(
              host: opts[:rhost] || rhost,
              port: (opts[:rport] || rport).to_i,
              timeout: (opts[:timeout] || timeout).to_i,
              context:
                {
                  'Msf'        => framework,
                  'MsfExploit' => self,
                },
              protocol: 'tcp'
            )

            disconnect if client
            self.client = kerb_client

            kerb_client
          end

          # Disconnects the Kerberos client
          #
          # @param kerb_client [Rex::Proto::Kerberos::Client] the client to disconnect
          def disconnect(kerb_client = client)
            kerb_client.close if kerb_client

            if kerb_client == client
              self.client = nil
            end
          end

          # Performs cleanup as necessary, disconnecting the Kerberos client
          # if it's still established.
          def cleanup
            super
            disconnect
          end

          # Sends a kerberos AS request and reads the response
          #
          # @param opts [Hash]
          # @return [Rex::Proto::Kerberos::Model::KdcResponse]
          # @see Msf::Kerberos::Client::AsRequest#build_as_request
          # @see Rex::Proto::Kerberos::Model::KdcResponse
          def send_request_as(opts = {})
            connect(opts)
            req = opts.fetch(:req) { build_as_request(opts) }
            res = client.send_recv(req)
            disconnect
            res
          end

          # Sends a kerberos AS request and reads the response
          #
          # @param opts [Hash]
          # @return [Rex::Proto::Kerberos::Model::KdcResponse]
          # @see Msf::Kerberos::Client::TgsRequest#build_tgs_request
          # @see Rex::Proto::Kerberos::Model::KdcResponse
          def send_request_tgs(opts = {})
            connect(opts)
            req = opts.fetch(:req) { build_tgs_request(opts) }
            res = client.send_recv(req)
            disconnect
            res
          end

          # Select a cipher that both the server and client support,
          # preferencing ours in order. This may just be the default
          # behaviour on Windows, but let's be sure about it.
          #
          # @param client_etypes [Array<Integer>] Available ciphers on the client side (etypes from Rex::Proto::Kerberos::Crypto::Encryption)
          # @param server_etypeinfos [Array<Rex::Proto::Kerberos::Model::EtypeInfo2>] Available ciphers (including additional info such as salts) on the server
          # @return [Rex::Proto::Kerberos::Model::EtypeInfo] The selected cipher
          def select_cipher(client_etypes, server_etypeinfos)
            client_etypes.each do |client_etype|
              server_etypeinfos.etype_info2_entries.each do |server_etypeinfo|
                if server_etypeinfo.etype == client_etype
                  return server_etypeinfo
                end
              end
            end
          end

          # Sends the required kerberos AS requests for a kerberos Ticket Granting Ticket
          #
          # @param options [Hash]
          # @return [Msf::Exploit::Remote::Kerberos::Model::Tgt] ticket granting ticket
          # @raise [Rex::Proto::Kerberos::Model::Error::KerberosError] if the provided credentials are invalid
          def send_request_tgt(options = {})
            realm = options[:realm]
            server_name = options[:server_name]
            client_name = options[:client_name]
            password = options[:password]
            request_pac = options.fetch(:request_pac, true)

            # First stage: Send an initial AS-REQ request, used to exchange supported encryption methods.
            # The server may respond with a ticket granting ticket (TGT) immediately,
            # or the client may require preauthentication, and a second AS-REQ is required

            now = Time.now.utc
            expiry_time = now + 1.day
            offered_etypes = Rex::Proto::Kerberos::Crypto::Encryption::DefaultOfferedEtypes
            initial_as_req = build_as_request(
              pa_data: [
                build_pa_pac_request(pac_request_value: request_pac)
              ],
              body: build_as_request_body(
                client_name: client_name,
                server_name: server_name,
                realm: realm,

                etype: offered_etypes,

                # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
                from: nil,
                till: expiry_time,
                rtime: expiry_time
              )
            )

            initial_as_res = send_request_as(req: initial_as_req)

            # If we receive a AS_REP response immediately, no-preauthentication was required and we can return immediately
            if initial_as_res.msg_type == Rex::Proto::Kerberos::Model::AS_REP
              return Msf::Exploit::Remote::Kerberos::Model::Tgt.new(
                as_rep: initial_as_res,
                preauth_required: false
              )
            end

            # Verify error codes. Anything other than the server requiring an additional preauth request is considered a failure.
            if initial_as_res.msg_type == Rex::Proto::Kerberos::Model::KRB_ERROR && initial_as_res.error_code != Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_PREAUTH_REQUIRED
              if initial_as_res.error_code == Rex::Proto::Kerberos::Model::Error::ErrorCodes::KDC_ERR_ETYPE_NOSUPP
                raise Rex::Proto::Kerberos::Model::Error::KerberosEncryptionNotSupported.new(encryption_type: offered_etypes)
              end

              raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: initial_as_res)
            end

            # Second stage: Send an additional AS-REQ request with preauthentication provided
            # Note that Clock skew issues may be raised at this point

            server_ciphers = initial_as_res.e_data_as_pa_data.etype_info2
            selected_etypeinfo = select_cipher(offered_etypes, server_ciphers)
            selected_etype = selected_etypeinfo.etype
            salt = selected_etypeinfo.salt
            params = selected_etypeinfo.s2kparams

            encryptor = Rex::Proto::Kerberos::Crypto::Encryption::from_etype(selected_etype)
            password_digest = encryptor.string_to_key(password, salt, params)

            preauth_as_req = build_as_request(
              pa_data: [
                build_as_pa_time_stamp(key: password_digest, etype: selected_etype),
                build_pa_pac_request(pac_request_value: request_pac)
              ],
              body: build_as_request_body(
                client_name: client_name,
                server_name: server_name,
                realm: realm,
                key: password_digest,

                etype: [selected_etype],

                # Specify nil to ensure the KDC uses the current time for the desired starttime of the requested ticket
                from: nil,
                till: expiry_time,
                rtime: expiry_time
              )
            )

            preauth_as_res = send_request_as(req: preauth_as_req)
            if preauth_as_res.msg_type != Rex::Proto::Kerberos::Model::AS_REP
              raise ::Rex::Proto::Kerberos::Model::Error::KerberosError.new(res: preauth_as_res)
            end

            Msf::Exploit::Remote::Kerberos::Model::Tgt.new(
              as_rep: preauth_as_res,
              preauth_required: true
            )
          end
        end
      end
    end
  end
end
